<html>
<head>
    <style type="text/css">
        * {
            margin: 0;
            padding: 0;
            font-family: Arial, sans-serif;
        }

        h1 {
            font-size: 70px;
        }

        h2 {
            margin: 8px 0;
        }
    </style>
    <script type="text/javascript" src="input_handling.js"></script>
    <script type="text/javascript">

        const WIN_AMOUNT = 7;

        Math.trunc = Math.trunc || function (x) {
                    return ~~x;
                };

        // Objects rendered in the slime engine
        // need an x and a y parameter
        function newBall(radius, color) {
            return {
                radius: radius,
                color: color,
                x: 0,
                y: 0,
                velocityX: 0,
                velocityY: 0,
                render: function () {
                    var xPix = this.x * pixelsPerUnitX;
                    var yPix = courtYPix - (this.y * pixelsPerUnitY);
                    // The original game's ball looked bigger then
                    // it was, so we add 2 pixels here to the radius
                    var radiusPix = this.radius * pixelsPerUnitY + 2;

                    ctx.fillStyle = ballColor;
                    ctx.beginPath();
                    ctx.arc(xPix, yPix, radiusPix, 0, 2 * Math.PI);
                    ctx.fill();
                }
            };
        }
        function newSlime(onLeft, radius, color) {
            return {
                onLeft: onLeft,
                radius: radius,
                color: color,
                img: null,
                x: 0,
                y: 0,
                velocityX: 0,
                velocityY: 0,
                render: function () {
                    var xPix = this.x * pixelsPerUnitX;
                    var yPix = courtYPix - (this.y * pixelsPerUnitY);
                    var radiusPix = this.radius * pixelsPerUnitY;

                    ctx.fillStyle = this.color;
                    ctx.beginPath();
                    ctx.arc(xPix, yPix, radiusPix, Math.PI, 2 * Math.PI);
                    ctx.fill();

                    // Draw Eyes
                    var eyeX = this.x + (this.onLeft ? 1 : -1) * this.radius / 4;
                    var eyeY = this.y + this.radius / 2;
                    var eyeXPix = eyeX * pixelsPerUnitX;
                    var eyeYPix = courtYPix - (eyeY * pixelsPerUnitY);
                    ctx.translate(eyeXPix, eyeYPix);
                    ctx.fillStyle = '#fff';
                    ctx.beginPath();
                    ctx.arc(0, 0, radiusPix / 4, 0, 2 * Math.PI);
                    ctx.fill();

                    // Draw Pupil
                    var dx = ball.x - eyeX;
                    var dy = eyeY - ball.y;
                    var dist = Math.sqrt(dx * dx + dy * dy);
                    var rPixOver8 = radiusPix / 8;
                    ctx.fillStyle = '#000';
                    ctx.beginPath();
                    ctx.arc(rPixOver8 * dx / dist, rPixOver8 * dy / dist, rPixOver8, 0, 2 * Math.PI);
                    ctx.fill();
                    ctx.setTransform(1, 0, 0, 1, 0, 0);
                }
            };
        }

        var GAME_STATE_RUNNING = 1;
        var GAME_STATE_POINT_PAUSE = 2;
        var GAME_STATE_SHOW_WINNER = 3;

        // MENU DATA
        var menuDiv;
        var nextSlimeIndex;

        var gameState;

        // RENDER DATA
        var ctx;
        var canvas;
        var viewWidth;
        var viewHeight;
        var courtYPix;
        var pixelsPerUnitX;
        var pixelsPerUnitY;
        var updatesToPaint;
        var skyColor;
        var groundColor;
        var ballColor;
        var backTextColor;
        var gameIntervalObject;

        // GAME DATA
        var gameWidth, gameHeight;
        var ball;
        var slimeLeft;
        var slimeRight;
        var slimeLeftScore;
        var slimeRightScore;
        var leftWon;

        // Game Update Functions
        function updateSlimeVelocitiesWithKeys(slime, moveLeftKey, moveRightKey, jumpKey) {
            if (keysDown[moveLeftKey]) {
                if (keysDown[moveRightKey]) {
                    slime.velocityX = 0;
                } else {
                    slime.velocityX = -8;
                }
            } else if (keysDown[moveRightKey]) {
                slime.velocityX = 8;
            } else {
                slime.velocityX = 0;
            }

            if (slime.y == 0 && keysDown[jumpKey]) {
                slime.velocityY = 31;
            }
        }

        function updateSlime(s, leftLimit, rightLimit) {
            if (s.velocityX != 0) {
                s.x += s.velocityX;
                if (s.x < leftLimit) s.x = leftLimit;
                else if (s.x > rightLimit) s.x = rightLimit;
            }
            if (s.velocityY != 0 || s.y > 0) {
                s.velocityY -= 2;
                s.y += s.velocityY;
                if (s.y < 0) {
                    s.y = 0;
                    s.velocityY = 0;
                }
            }
        }

        var MAX_VELOCITY_X = 15;
        var MAX_VELOCITY_Y = 22;

        function collisionBallSlime(s) {
            var dx = 2 * (ball.x - s.x);
            var dy = ball.y - s.y;
            var dist = Math.trunc(Math.sqrt(dx * dx + dy * dy));

            var dVelocityX = ball.velocityX - s.velocityX;
            var dVelocityY = ball.velocityY - s.velocityY;

            if (dy > 0 && dist < ball.radius + s.radius && dist > FUDGE) {
                ball.x = s.x + Math.trunc(Math.trunc((s.radius + ball.radius) / 2) * dx / dist);
                ball.y = s.y + Math.trunc((s.radius + ball.radius) * dy / dist);

                var something = Math.trunc((dx * dVelocityX + dy * dVelocityY) / dist);

                if (something <= 0) {
                    ball.velocityX += Math.trunc(s.velocityX - 2 * dx * something / dist);
                    ball.velocityY += Math.trunc(s.velocityY - 2 * dy * something / dist);
                    if (ball.velocityX < -MAX_VELOCITY_X) ball.velocityX = -MAX_VELOCITY_X;
                    else if (ball.velocityX > MAX_VELOCITY_X) ball.velocityX = MAX_VELOCITY_X;
                    if (ball.velocityY < -MAX_VELOCITY_Y) ball.velocityY = -MAX_VELOCITY_Y;
                    else if (ball.velocityY > MAX_VELOCITY_Y) ball.velocityY = MAX_VELOCITY_Y;
                }
            }
        }

        var FUDGE = 5; // not sure why this is needed

        function updateBall() {
            ball.velocityY += -1; // gravity
            if (ball.velocityY < -MAX_VELOCITY_Y) {
                ball.velocityY = -MAX_VELOCITY_Y;
            }

            ball.x += ball.velocityX;
            ball.y += ball.velocityY;

            collisionBallSlime(slimeLeft);
            collisionBallSlime(slimeRight);

            // handle wall hits
            if (ball.x < 15) {
                ball.x = 15;
                ball.velocityX = -ball.velocityX;
            } else if (ball.x > 985) {
                ball.x = 985;
                ball.velocityX = -ball.velocityX;
            }
            // hits the post
            if (ball.x > 480 && ball.x < 520 && ball.y < 140) {
                // bounces off top of net
                if (ball.velocityY < 0 && ball.y > 130) {
                    ball.velocityY *= -1;
                    ball.y = 130;
                } else if (ball.x < 500) { // hits side of net
                    ball.x = 480;
                    ball.velocityX = ball.velocityX >= 0 ? -ball.velocityX : ball.velocityX;
                } else {
                    ball.x = 520;
                    ball.velocityX = ball.velocityX <= 0 ? -ball.velocityX : ball.velocityX;
                }
            }

            // Check for end of point
            if (ball.y < 0) {
                if (ball.x > 500) {
                    leftWon = true;
                    slimeLeftScore++;
                } else {
                    leftWon = false;
                    slimeRightScore++;
                }

                endPoint();
            }
        }

        function updateFrame() {
            updateSlimeVelocitiesWithKeys(slimeLeft, KEY_A, KEY_D, KEY_W);
            updateSlimeVelocitiesWithKeys(slimeRight, KEY_LEFT, KEY_RIGHT, KEY_UP);

            updateSlime(slimeLeft, 50, 445);
            updateSlime(slimeRight, 555, 950);
            updateBall();
        }

        function renderPoints(score, initialX, xDiff) {
            ctx.fillStyle = '#ff0';
            var x = initialX;
            for (var i = 0; i < score; i++) {
                ctx.beginPath();
                ctx.arc(x, 25, 12, 0, 2 * Math.PI);
                ctx.fill();
                x += xDiff;
            }
            ctx.strokeStyle = backTextColor;
            ctx.lineWidth = 2;
            x = initialX;
            for (var j = 0; j < WIN_AMOUNT; j++) {
                ctx.beginPath();
                ctx.arc(x, 25, 12, 0, 2 * Math.PI);
                ctx.stroke();
                x += xDiff;
            }
        }

        // Rendering Functions
        function renderBackground() {
            ctx.fillStyle = skyColor;
            ctx.fillRect(0, 0, viewWidth, courtYPix);
            ctx.fillStyle = groundColor;
            ctx.fillRect(0, courtYPix, viewWidth, viewHeight - courtYPix);
            ctx.fillStyle = '#fff';
            ctx.fillRect(viewWidth / 2 - 2, 7 * viewHeight / 10, 4, viewHeight / 10 + 5);
            // render scores
            renderPoints(slimeLeftScore, 30, 40);
            renderPoints(slimeRightScore, viewWidth - 30, -40);
        }

        // GAME CODE
        function renderGame() {
            if (updatesToPaint == 0) {
                console.log("ERROR: render called but not ready to paint");
            } else {
                if (updatesToPaint > 1) {
                    console.log("WARNING: render missed " + (updatesToPaint - 1) + " frame(s)");
                }
                renderBackground();
                ctx.fillStyle = '#000';
                ball.render();
                slimeLeft.render();
                slimeRight.render();
                updatesToPaint = 0;
            }
        }

        function gameIteration() {
            if (gameState == GAME_STATE_RUNNING) {
                if (updatesToPaint > 0) {
                    console.log("WARNING: updating frame before it was rendered");
                }

                updateFrame();
                updatesToPaint++;
                if (updatesToPaint == 1) {
                    requestAnimationFrame(renderGame);
                }
            }
        }

        //noinspection JSUnusedLocalSymbols
        function spaceKeyDown() {
            if (gameState == GAME_STATE_SHOW_WINNER) {
                start();
            }
        }

        function endMatch() {
            gameState = GAME_STATE_SHOW_WINNER;
            clearInterval(gameIntervalObject);
            menuDiv.innerHTML = '<div style="text-align:center;">' +
                    '<h1 style="margin:50px 0 20px 0;">Player ' + (leftWon ? '1' : '2') + ' Wins!</h1>' +
                    "Press 'space' for rematch..." +
                    '</div>';

            menuDiv.style.display = 'block';
            canvas.style.display = 'none';
        }

        function startNextPoint() {
            initRound(leftWon);
            updatesToPaint = 0;
            gameState = GAME_STATE_RUNNING;
        }

        function endPoint() {
            if (slimeLeftScore >= WIN_AMOUNT) {
                endMatch(true);
                return;
            }
            if (slimeRightScore >= WIN_AMOUNT) {
                endMatch(false);
                return;
            }

            gameState = GAME_STATE_POINT_PAUSE;
            requestAnimationFrame(renderGame);

            setTimeout(function () {
                if (gameState == GAME_STATE_POINT_PAUSE) {
                    startNextPoint();
                }
            }, 700);
        }

        function initRound(server) {
            ball.x = server ? 200 : 800;
            ball.y = 356;
            ball.velocityX = 0;
            ball.velocityY = 0;

            slimeLeft.x = 200;
            slimeLeft.y = 0;
            slimeLeft.velocityX = 0;
            slimeLeft.velocityY = 0;

            slimeRight.x = 800;
            slimeRight.y = 0;
            slimeRight.velocityX = 0;
            slimeRight.velocityY = 0;
        }

        function updateWindowSize(width, height) {
            viewWidth = width;
            viewHeight = height;
            console.log("ViewSize x: " + width + ", y: " + height);
            pixelsPerUnitX = width / gameWidth;
            pixelsPerUnitY = height / gameHeight;
            console.log("GAMESIZE x: " + gameWidth + ", y: " + gameHeight);
            console.log("PPU      x: " + pixelsPerUnitX + ", y: " + pixelsPerUnitY);
            courtYPix = 4 * viewHeight / 5;
        }

        function setupView(view) {
            view.style.position = 'absolute';
            view.style.left = '0';
            view.style.top = '0';
        }

        function onInitialLoad() {
            var contentDiv = document.getElementById('GameContentDiv');

            // Create Render objects
            canvas = document.createElement('canvas');
            canvas.width = 750;
            canvas.height = 375;
            setupView(canvas, true);
            canvas.style.display = 'none';

            ctx = canvas.getContext("2d");
            ctx.font = "20px Arial";

            gameWidth = 1000;
            gameHeight = 1000;

            // Setup Render Data
            updateWindowSize(canvas.width, canvas.height);
            contentDiv.appendChild(canvas);

            // Create Menu Objects
            menuDiv = document.createElement('div');
            setupView(menuDiv, false);
            menuDiv.style.width = '750px';
            menuDiv.style.height = '375px';

            menuDiv.style.background = "#ca6 no-repeat";
            contentDiv.appendChild(menuDiv);

            // Initialize Game Data
            nextSlimeIndex = 0;
            ball = newBall(25, '#ff0');
            slimeLeft = newSlime(true, 100, '#0f0');
            slimeRight = newSlime(false, 100, '#f00');

            start()
        }

        // Menu Functions
        function start() {
            slimeLeftScore = 0;
            slimeRightScore = 0;

            skyColor = '#00f';
            backTextColor = '#000';
            groundColor = '#888';
            ballColor = '#fff';

            initRound(true);

            updatesToPaint = 0;
            gameState = GAME_STATE_RUNNING;
            renderBackground(); // clear the field
            canvas.style.display = 'block';
            menuDiv.style.display = 'none';
            gameIntervalObject = setInterval(gameIteration, 20);
        }
    </script>
</head>

<body onload="onInitialLoad()" style="text-align:center;">
<div id="ContentDiv" style="position:relative;margin:15px auto;width:750px;">
    <div id="GameContentDiv"></div>
</div>
</body>
</html>
